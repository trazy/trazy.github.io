---
title: 쓰레드와 비동기 처리
datetime: '2022-07-15T22:43:00.000+09:00'
description: 비동기를 쓰기 전에 보면 좋을지도?
tags: ['concurrency', 'async', 'await', 'non-blocking']
---

# 최초의 코드

```kotlin
import java.util.concurrent.Executors

fun main(args: Array<String>) {
    var vault = 5000
    for (i in 0..999) {
        println("Hello this is thread $i")
        var next = vault + if (i % 2 == 0) 200 else -200
        Thread.sleep(10);
        vault = next
    }
    println("last vault value is $vault")
    println("Finished all threads")
}
```

![실행결과1](/assets/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)

- 느려! 느려도 너무 느리다!!!
- 우린 더 빠르게, 더 많이 실행하고 싶다!!

# 다중 프로세스 Multi-Process 의 출현

- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )
- Daemon 의 사용
- IPC ( Inter Process Communication ) 의 사용

# 쓰레드를 사용한 코드

- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )
- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )

```kotlin
import java.util.concurrent.Executors

fun main(args: Array<String>) {
    val executor = Executors.newFixedThreadPool(100)
    var vault = 5000
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println("Hello this is thread $i")
            Thread.sleep(10)
            vault += 200
        } else Runnable {
            println("Hello this is thread $i")
            Thread.sleep(10)
            vault -= 200
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println("waiting thread terminating")
    }
    println("last vault value is $vault")
    println("Finished all threads")
}
```

![실행결과2](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)

- 충분히 빨라졌다!
- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )
- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )

# Thread-Safe한 자료형으로 쓰레드를 사용한 코드

![실행결과3](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)


- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.
- 하지만 그래도 문제는 존재한다

# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?

```kotlin
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicInteger

fun main(args: Array<String>) {
    val executor = Executors.newFixedThreadPool(4)
    var vault = AtomicInteger(5000)
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println("Hello this is thread $i")
            Thread.sleep(10)
            vault.addAndGet(200)
        } else Runnable {
            println("Hello this is thread $i")
            Thread.sleep(10)
            vault.addAndGet(-200)
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println("waiting thread terminating")
    }
    println("last vault value is $vault")
    println("Finished all threads")
}
```

![실행결과4](/assets/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)

- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.
- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.
  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.
  * OS 모든 resource를 너 혼자 쓸래? 라는 이유도 있을 것이다.
  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.
- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.


# 코루틴을 사용한다면?

```kotlin
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.*
import java.util.concurrent.Executors

fun main(args: Array<String>) {
    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()
    var vault = AtomicInteger(5000)
    runBlocking {
        for (i in 0..999) {
            if (i % 2 == 0) launch(ctx) {
                delay(10)
                println("Hello this is coroutine $i")
                vault.addAndGet(200)
            } else launch(ctx) {
                delay(10)
                println("Hello this is coroutine $i")
                vault.addAndGet(-200)
            }
        }
    }
    ctx.close()
    println("last vault value is $vault")
    println("Finished all threads")
}
```

![실행결과5](/assets/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)

# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?

원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시

보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공
  - java에서는 future
  - js/ts에서는 promise

위의 내용을 async 라는 키워드를 통해 해당 함수가 내부에서 비동기적인 뭔가를 한다는 것을 마킹해둠

async function은 await 이라는 키워드를 통해 완료된 시점 리턴된 값을 전달함

비동기 작업하는 부분으로 오면 CPU의 사용권을 다른 코드가 실행할 수 있도록 넘겨주고 해당 부분은 처리가 끝날때까지 기다렸다가 끝나면 그때 다시 CPU의 실행권을 쥐고 실행됨

# 그래서 빠르네? 정말 그럴까?

- *There is no silver bullet!*
- async 안에서 sync를 사용하기 시작하면 어떨까?

```kotlin
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.*
import java.util.concurrent.Executors

fun main(args: Array<String>) {
    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()
    var vault = AtomicInteger(5000)
    runBlocking {
        for (i in 0..999) {
            if (i % 2 == 0) launch(ctx) {
                Thread.sleep(10)
                println("Hello this is coroutine $i")
                vault.addAndGet(200)
            } else launch(ctx) {
                Thread.sleep(10)
                println("Hello this is coroutine $i")
                vault.addAndGet(-200)
            }
        }
    }
    ctx.close()
    println("last vault value is $vault")
    println("Finished all threads")
}
```

![실행결과6](/assets/20220725-2241xx-thread_vs_async/2022-07-31_213534.png)

**쓰레드로 할때랑 별 차이가 없다!?**

- 우리가 그냥 만드는 함수는 대부분 blocking을 하게 된다. 그러면 async의 이점을 아무것도 누릴 수 없게 된다.
- 우리가 시간이 오래 걸리는, 완료될 시 슬랙으로 알림 보내주도록 만든 코드를 돌려놓고 커피마시러 가는 것이 async의 이점과 완전히 같은 개념이다.
  - 생각해보자. 시간이 오래 걸리는 코드를 실행해놓고 다 끝날 때까지 기다린 다음에 커피 마시러가면 그것이 효율적인 시간 활용인가?

# 왜 async는 유행했나?

- 예를 들어 API가 1개가 제공되는데 이 1개의 API에 DB를 호출하고 있고 그 쿼리가 1분이 걸린다고 치자.
- 이 API는 총 8개의 실행 스레드를 가진 웹 서버에서 실행 중이다.
- 사람이 몰려서 여러 곳에서 마구 API를 요청하기 시작한다.
- 9번째 요청부터는 8번 먼저 들어온 API중 1개라도 처리가 끝날 1분이 될때까지 기다려야된다.

## 결과

- 서버의 자원은 남아돈다. CPU 사용률도, RAM도 NETWORK I/O도 멍때리는 것 같을 것이다.
- 더 많은 요청을 수용하려면?
  - 쓰레드를 더 많이 설정한다. ( PHP나 Python 같은 애들은 process pool을 더 키운다. )
    - 효율이 나쁘다는게 눈에 보인다. 그러나 어쩔 수 없다.
  - 쓰레드를 늘리는 것도 한계에 달하면 수평적 확장을 시도한다.
    - 서버 비용은 어쩔꺼냐?

## 개발자의 절망

- 아 씁 맨날 DB만 불러대고 별 하는 것도 없네. 우린 DB를 쓰기 위한 중간 인터페이스를 만드는 것 뿐이야. 뭣도 없다고!!
- 어? DB 요청만 줄기차게 해?
- **어? 뭣도 하는 것도 없는데 async로 io 처리만 따로하게 만들면 더 많은 요청을 수용할 수 있겠네?!**

# 결론

쓰레드로 하면 이렇다.

![실행구조1](/assets/20220725-2241xx-thread_vs_async/drawio.1.png)

하지만 async로 하면 이렇게 바뀐다.

![실행구조2](/assets/20220725-2241xx-thread_vs_async/drawio.2.png)

딱 보기에도 async가 더 빠르지 않은가?

하지만 저걸 단 1개의 쓰레드에서 실행하는 blocking하는 함수들이라 생각해보자.

바로 끔찍한 결론이 느껴진다면 오늘은 여기까지
