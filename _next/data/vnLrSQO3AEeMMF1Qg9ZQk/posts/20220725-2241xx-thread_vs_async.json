{"pageProps":{"slug":"20220725-2241xx-thread_vs_async","content":"\r\n# 최초의 코드\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array<String>) {\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        println(\"Hello this is thread $i\")\r\n        var next = vault + if (i % 2 == 0) 200 else -200\r\n        Thread.sleep(10);\r\n        vault = next\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과1](/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)\r\n\r\n- 느려! 느려도 너무 느리다!!!\r\n- 우린 더 빠르게, 더 많이 실행하고 싶다!!\r\n\r\n# 다중 프로세스 Multi-Process 의 출현\r\n\r\n- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )\r\n- Daemon 의 사용\r\n- IPC ( Inter Process Communication ) 의 사용\r\n\r\n# 쓰레드를 사용한 코드\r\n\r\n- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )\r\n- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array<String>) {\r\n    val executor = Executors.newFixedThreadPool(100)\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault += 200\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault -= 200\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과2](/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)\r\n\r\n- 충분히 빨라졌다!\r\n- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )\r\n- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )\r\n\r\n# Thread-Safe한 자료형으로 쓰레드를 사용한 코드\r\n\r\n![실행결과3](/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)\r\n\r\n\r\n- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.\r\n- 하지만 그래도 문제는 존재한다\r\n\r\n# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\nimport java.util.concurrent.atomic.AtomicInteger\r\n\r\nfun main(args: Array<String>) {\r\n    val executor = Executors.newFixedThreadPool(4)\r\n    var vault = AtomicInteger(5000)\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(200)\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(-200)\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과4](/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)\r\n\r\n- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.\r\n- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.\r\n  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.\r\n  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.\r\n- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.\r\n\r\n\r\n# 코루틴을 사용한다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.atomic.AtomicInteger\r\nimport kotlinx.coroutines.*\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array<String>) {\r\n    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()\r\n    var vault = AtomicInteger(5000)\r\n    runBlocking {\r\n        for (i in 0..999) {\r\n            if (i % 2 == 0) launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(200)\r\n            } else launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(-200)\r\n            }\r\n        }\r\n    }\r\n    ctx.close()\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과5](/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)\r\n\r\n# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?\r\n\r\n원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시\r\n\r\n보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공\r\n  - java에서는 future\r\n  - js/ts에서는 promise\r\n\r\n위의 내용을 async 라는 키워드를 통해 해당 함수가 비동기의 방법을 통해 값을 리턴함을 마킹\r\n\r\nasync function은 await 이라는 키워드를 통해 완료된 시점 이후 해야할 일을 명시\r\n\r\n# 서버 프로그래머들에게 nodejs를 보며 열광하게 만들었던 주역 uvloop\r\n\r\n- io 처리에 대한 요청과 그 요청에 대한 완료 감지를 background thread pool을 만들어 관리\r\n  * 예를 들어 network i/o\r\n  * 예를 들어 file i/o\r\n- 이를 사용하는 어플리케이션들은 io 처리 쓰레드를 uvloop에게 넘기고 완료될때 그에 대한 처리만 할 수 있도록 변경됨\r\n- 하지만 그를 위해 언어 레벨에서, library들이, built-in 으로 비동기 처리를 지원할 방법이 필요함\r\n  * java에 nio2가 있었음에도 불구하고 남들 다 하는 비동기 처리를 손가락빨며 쳐다볼 수 밖에 없었던 이유\r\n  * 결국 너무 느린 발전속도로 jboss undertow 같은 WAS가 아닌 물건이 먼저 제시된 이유와 같음\r\n- uvloop는 V8 엔진의 심장으로 google chrome browser와 nodejs를 모두가 주목할 수 밖에 없게 만든 주역임\r\n- 그래서 비동기는 결국 공짜로 얻은 마법인가? Nope\r\n  * spring에서 async하게 돌아간다는 것들은 전부 background thread pool 설정을 필요로 함을 알 수 있음\r\n    - => uvloop 처럼 io 감지를 다른 백그라운드 쓰레드에게 맡겨놓은 것 뿐임\r\n  * 그런데 그렇게 만든게 과연 uvloop 만큼 빠를까? ( = 직접 알아보자 )\r\n\r\n\r\n# 그래서 빠르네? 정말 그럴까?\r\n\r\n- There is no silver bullet!\r\n","frontMatter":{"title":"쓰레드와 비동기 처리","datetime":"2022-07-15T22:43:00.000+09:00","description":"백엔드, 프론트엔드 개발자 초보에게 추천하는 튜토리얼","tags":["concurrency"]},"associatedPosts":[],"relatedByTags":[]},"__N_SSG":true}