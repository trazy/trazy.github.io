<!DOCTYPE html><html><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="description" content="끄적끄적"/><meta name="keywords" content="개발, development, blog, frontend, react, javascript, typescript, nextjs, vuejs, angular, angularjs, backend, nodejs, express, nestjs, java, spring, c#, .net, .net core, git, docker, kubernetes, k8s, helm, linux, stream, async, oop, fp, socket"/><meta name="author" content="trazy"/><meta property="og:type" content="blog"/><meta property="og:url" content="https://trazy.github.io"/><meta property="og:title" content="Flow@Log"/><meta property="og:description" content="끄적끄적"/><meta property="og:site_name" content="Flow@Log"/><meta property="og:locale" content="ko_KR"/><title>Flow@Log</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="13"/><link rel="preload" href="/_next/static/css/dcf3eaa28d2c6455.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dcf3eaa28d2c6455.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-1938e6a9293457d1.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-df853365e3782e3b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5f7f18d1df933f99.js" defer=""></script><script src="/_next/static/chunks/996-c8323b2f96a148d2.js" defer=""></script><script src="/_next/static/chunks/556-c8d990ba88c1d46b.js" defer=""></script><script src="/_next/static/chunks/pages/index-fa0003a034f7f5e7.js" defer=""></script><script src="/_next/static/XkgDFPRGmgMNjFTm3eMD2/_buildManifest.js" defer=""></script><script src="/_next/static/XkgDFPRGmgMNjFTm3eMD2/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="relative w-full min-h-full bg-gray-200"><div class="absolute bg-rose-700 w-full h-80 top-0 left-0"></div><nav class="relative container mx-auto h-20 text-white flex items-center px-4 md:px-36 text-left md:text-center"><div class="flex items-center gap-4"><h1 class="text-3xl cursor-pointer"><a href="/">Flow@Log</a></h1><p class="mt-4 text-sm">끄적끄적</p></div><div class="grow"><ul class="flex justify-end gap-8 uppercase font-extrabold"><li><a href="/">Home</a></li></ul></div></nav><div class="relative container md:px-32 mx-auto mt-20"><div class="w-full bg-white p-6 drop-shadow-xl"><main class="mt-12"><h2 class="text-xl font-bold text-center uppercase underline underline-offset-8 decoration-gray-400"><span class="">Recently Posts</span></h2><div class="py-12 flex flex-col gap-24"><article class="block overflow-hidden break-words px-16"><div class="flex gap-12"><div><div class="min-w-32 bg-white min-h-48 p-3 mb-4 font-medium"><div class="w-32 flex-none rounded-t lg:rounded-t-none lg:rounded-l text-center shadow-lg "><div class="block rounded-t overflow-hidden text-center "><div class="bg-rose-500 text-white py-1">July</div><div class="pt-1 border-l border-r border-white bg-white"><span class="text-5xl font-bold leading-tight">15</span></div><div class="border-l border-r border-b rounded-b-lg text-center border-white bg-white -pt-2 -mb-1"><span class="text-sm">Friday</span></div><div class="pb-2 border-l border-r border-b rounded-b-lg text-center border-white bg-white"><span class="text-xs leading-normal">2022 Q3</span></div></div></div></div></div><div><header class="pt-2"><h5 class="text-2xl font-bold"><a class="cursor-pointer" href="/posts/20220725-2241xx-thread_vs_async">쓰레드와 비동기 처리</a></h5></header><div class="pt-4"><ul class="flex gap-2"><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/concurrency">concurrency</a></li></ul></div><div class="pt-4"><p class="line-clamp-6 cursor-pointer" href="/posts/20220725-2241xx-thread_vs_async">
# 최초의 코드

```kotlin
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    var vault = 5000
    for (i in 0..999) {
        println(&quot;Hello this is thread $i&quot;)
        var next = vault + if (i % 2 == 0) 200 else -200
        Thread.sleep(10);
        vault = next
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과1](/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)

- 느려! 느려도 너무 느리다!!!
- 우린 더 빠르게, 더 많이 실행하고 싶다!!

# 다중 프로세스 Multi-Process 의 출현

- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )
- Daemon 의 사용
- IPC ( Inter Process Communication ) 의 사용

# 쓰레드를 사용한 코드

- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )
- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )

```kotlin
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    val executor = Executors.newFixedThreadPool(100)
    var vault = 5000
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault += 200
        } else Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault -= 200
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println(&quot;waiting thread terminating&quot;)
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과2](/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)

- 충분히 빨라졌다!
- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )
- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )

# Thread-Safe한 자료형으로 쓰레드를 사용한 코드

![실행결과3](/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)


- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.
- 하지만 그래도 문제는 존재한다

# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?

```kotlin
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicInteger

fun main(args: Array&lt;String&gt;) {
    val executor = Executors.newFixedThreadPool(4)
    var vault = AtomicInteger(5000)
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault.addAndGet(200)
        } else Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault.addAndGet(-200)
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println(&quot;waiting thread terminating&quot;)
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과4](/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)

- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.
- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.
  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.
  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.
- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.


# 코루틴을 사용한다면?

```kotlin
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.*
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()
    var vault = AtomicInteger(5000)
    runBlocking {
        for (i in 0..999) {
            if (i % 2 == 0) launch(ctx) {
                delay(10)
                println(&quot;Hello this is coroutine $i&quot;)
                vault.addAndGet(200)
            } else launch(ctx) {
                delay(10)
                println(&quot;Hello this is coroutine $i&quot;)
                vault.addAndGet(-200)
            }
        }
    }
    ctx.close()
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과5](/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)

# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?

원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시

보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공
  - java에서는 future
  - js/ts에서는 promise

위의 내용을 async 라는 키워드를 통해 해당 함수가 비동기의 방법을 통해 값을 리턴함을 마킹

async function은 await 이라는 키워드를 통해 완료된 시점 이후 해야할 일을 명시

# 서버 프로그래머들에게 nodejs를 보며 열광하게 만들었던 주역 uvloop

- io 처리에 대한 요청과 그 요청에 대한 완료 감지를 background thread pool을 만들어 관리
  * 예를 들어 network i/o
  * 예를 들어 file i/o
- 이를 사용하는 어플리케이션들은 io 처리 쓰레드를 uvloop에게 넘기고 완료될때 그에 대한 처리만 할 수 있도록 변경됨
- 하지만 그를 위해 언어 레벨에서, library들이, built-in 으로 비동기 처리를 지원할 방법이 필요함
  * java에 nio2가 있었음에도 불구하고 남들 다 하는 비동기 처리를 손가락빨며 쳐다볼 수 밖에 없었던 이유
  * 결국 너무 느린 발전속도로 jboss undertow 같은 WAS가 아닌 물건이 먼저 제시된 이유와 같음
- uvloop는 V8 엔진의 심장으로 google chrome browser와 nodejs를 모두가 주목할 수 밖에 없게 만든 주역임
- 그래서 비동기는 결국 공짜로 얻은 마법인가? Nope
  * spring에서 async하게 돌아간다는 것들은 전부 background thread pool 설정을 필요로 함을 알 수 있음
    - =&gt; uvloop 처럼 io 감지를 다른 백그라운드 쓰레드에게 맡겨놓은 것 뿐임
  * 그런데 그렇게 만든게 과연 uvloop 만큼 빠를까? ( = 직접 알아보자 )


# 그래서 빠르네? 정말 그럴까?

- There is no silver bullet!
</p></div><div class="pt-4 h-12"><a class="py-2 px-4 text-baseline bg-rose-500 hover:bg-rose-800 transition-colors font-bold text-white uppercase cursor-pointer rounded" href="/posts/20220725-2241xx-thread_vs_async">Read more</a></div></div></div></article></div></main></div></div><footer class="block text-center border-t-2 py-16"><p>© 2012~ trazy. All right reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"slug":"20220725-2241xx-thread_vs_async","datetime":"2022-07-15T22:43:00.000+09:00","title":"쓰레드와 비동기 처리","description":"백엔드, 프론트엔드 개발자 초보에게 추천하는 튜토리얼","tags":["concurrency"],"content":"\r\n# 최초의 코드\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        println(\"Hello this is thread $i\")\r\n        var next = vault + if (i % 2 == 0) 200 else -200\r\n        Thread.sleep(10);\r\n        vault = next\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과1](/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)\r\n\r\n- 느려! 느려도 너무 느리다!!!\r\n- 우린 더 빠르게, 더 많이 실행하고 싶다!!\r\n\r\n# 다중 프로세스 Multi-Process 의 출현\r\n\r\n- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )\r\n- Daemon 의 사용\r\n- IPC ( Inter Process Communication ) 의 사용\r\n\r\n# 쓰레드를 사용한 코드\r\n\r\n- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )\r\n- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val executor = Executors.newFixedThreadPool(100)\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault += 200\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault -= 200\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과2](/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)\r\n\r\n- 충분히 빨라졌다!\r\n- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )\r\n- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )\r\n\r\n# Thread-Safe한 자료형으로 쓰레드를 사용한 코드\r\n\r\n![실행결과3](/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)\r\n\r\n\r\n- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.\r\n- 하지만 그래도 문제는 존재한다\r\n\r\n# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\nimport java.util.concurrent.atomic.AtomicInteger\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val executor = Executors.newFixedThreadPool(4)\r\n    var vault = AtomicInteger(5000)\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(200)\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(-200)\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과4](/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)\r\n\r\n- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.\r\n- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.\r\n  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.\r\n  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.\r\n- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.\r\n\r\n\r\n# 코루틴을 사용한다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.atomic.AtomicInteger\r\nimport kotlinx.coroutines.*\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()\r\n    var vault = AtomicInteger(5000)\r\n    runBlocking {\r\n        for (i in 0..999) {\r\n            if (i % 2 == 0) launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(200)\r\n            } else launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(-200)\r\n            }\r\n        }\r\n    }\r\n    ctx.close()\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과5](/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)\r\n\r\n# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?\r\n\r\n원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시\r\n\r\n보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공\r\n  - java에서는 future\r\n  - js/ts에서는 promise\r\n\r\n위의 내용을 async 라는 키워드를 통해 해당 함수가 비동기의 방법을 통해 값을 리턴함을 마킹\r\n\r\nasync function은 await 이라는 키워드를 통해 완료된 시점 이후 해야할 일을 명시\r\n\r\n# 서버 프로그래머들에게 nodejs를 보며 열광하게 만들었던 주역 uvloop\r\n\r\n- io 처리에 대한 요청과 그 요청에 대한 완료 감지를 background thread pool을 만들어 관리\r\n  * 예를 들어 network i/o\r\n  * 예를 들어 file i/o\r\n- 이를 사용하는 어플리케이션들은 io 처리 쓰레드를 uvloop에게 넘기고 완료될때 그에 대한 처리만 할 수 있도록 변경됨\r\n- 하지만 그를 위해 언어 레벨에서, library들이, built-in 으로 비동기 처리를 지원할 방법이 필요함\r\n  * java에 nio2가 있었음에도 불구하고 남들 다 하는 비동기 처리를 손가락빨며 쳐다볼 수 밖에 없었던 이유\r\n  * 결국 너무 느린 발전속도로 jboss undertow 같은 WAS가 아닌 물건이 먼저 제시된 이유와 같음\r\n- uvloop는 V8 엔진의 심장으로 google chrome browser와 nodejs를 모두가 주목할 수 밖에 없게 만든 주역임\r\n- 그래서 비동기는 결국 공짜로 얻은 마법인가? Nope\r\n  * spring에서 async하게 돌아간다는 것들은 전부 background thread pool 설정을 필요로 함을 알 수 있음\r\n    - =\u003e uvloop 처럼 io 감지를 다른 백그라운드 쓰레드에게 맡겨놓은 것 뿐임\r\n  * 그런데 그렇게 만든게 과연 uvloop 만큼 빠를까? ( = 직접 알아보자 )\r\n\r\n\r\n# 그래서 빠르네? 정말 그럴까?\r\n\r\n- There is no silver bullet!\r\n"}],"tags":["concurrency"]},"__N_SSG":true},"page":"/","query":{},"buildId":"XkgDFPRGmgMNjFTm3eMD2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>