<!DOCTYPE html><html><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="description" content="끄적끄적"/><meta name="keywords" content="개발, development, blog, frontend, react, javascript, typescript, nextjs, vuejs, angular, angularjs, backend, nodejs, express, nestjs, java, spring, c#, .net, .net core, git, docker, kubernetes, k8s, helm, linux, stream, async, oop, fp, socket"/><meta name="author" content="trazy"/><meta property="og:type" content="blog"/><meta property="og:url" content="https://trazy.github.io"/><meta property="og:title" content="Flow@Log"/><meta property="og:description" content="끄적끄적"/><meta property="og:site_name" content="Flow@Log"/><meta property="og:locale" content="ko_KR"/><title>Flow@Log</title><link rel="icon" href="/favicon.ico"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-S3CDH8XL82"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S3CDH8XL82');
</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/dcf3eaa28d2c6455.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dcf3eaa28d2c6455.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-1938e6a9293457d1.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-df853365e3782e3b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f5332b136cb59f83.js" defer=""></script><script src="/_next/static/chunks/996-c8323b2f96a148d2.js" defer=""></script><script src="/_next/static/chunks/556-c8d990ba88c1d46b.js" defer=""></script><script src="/_next/static/chunks/pages/index-ccb348d43732f1b3.js" defer=""></script><script src="/_next/static/lzqqrgsdoJkOt9BxdDE46/_buildManifest.js" defer=""></script><script src="/_next/static/lzqqrgsdoJkOt9BxdDE46/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="relative w-full min-h-full bg-gray-200"><div class="absolute bg-rose-700 w-full h-80 top-0 left-0"></div><nav class="relative container mx-auto h-20 text-white flex items-center px-4 md:px-36 text-left md:text-center"><div class="flex items-center gap-4"><h1 class="text-3xl cursor-pointer"><a href="/">Flow@Log</a></h1><p class="mt-4 text-sm">끄적끄적</p></div><div class="grow"><ul class="flex justify-end gap-8 uppercase font-extrabold"><li><a href="/">Home</a></li></ul></div></nav><div class="relative container md:px-32 mx-auto mt-20"><div class="w-full bg-white p-6 drop-shadow-xl"><main class="mt-12"><h2 class="text-xl font-bold text-center uppercase underline underline-offset-8 decoration-gray-400"><span class="">Recently Posts</span></h2><div class="py-12 flex flex-col gap-24"><article class="block overflow-hidden break-words px-16"><div class="flex gap-12"><div><div class="min-w-32 bg-white min-h-48 p-3 mb-4 font-medium"><div class="w-32 flex-none rounded-t lg:rounded-t-none lg:rounded-l text-center shadow-lg "><div class="block rounded-t overflow-hidden text-center "><div class="bg-rose-500 text-white py-1">July</div><div class="pt-1 border-l border-r border-white bg-white"><span class="text-5xl font-bold leading-tight">15</span></div><div class="border-l border-r border-b rounded-b-lg text-center border-white bg-white -pt-2 -mb-1"><span class="text-sm">Friday</span></div><div class="pb-2 border-l border-r border-b rounded-b-lg text-center border-white bg-white"><span class="text-xs leading-normal">2022 Q3</span></div></div></div></div></div><div><header class="pt-2"><h5 class="text-2xl font-bold"><a class="cursor-pointer" href="/posts/20220725-2241xx-thread_vs_async">쓰레드와 비동기 처리</a></h5></header><div class="pt-4"><ul class="flex gap-2"><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/concurrency">concurrency</a></li><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/async">async</a></li><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/await">await</a></li><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/non-blocking">non-blocking</a></li></ul></div><div class="pt-4"><p class="line-clamp-6 cursor-pointer" href="/posts/20220725-2241xx-thread_vs_async">
# 최초의 코드

```kotlin
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    var vault = 5000
    for (i in 0..999) {
        println(&quot;Hello this is thread $i&quot;)
        var next = vault + if (i % 2 == 0) 200 else -200
        Thread.sleep(10);
        vault = next
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과1](/assets/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)

- 느려! 느려도 너무 느리다!!!
- 우린 더 빠르게, 더 많이 실행하고 싶다!!

# 다중 프로세스 Multi-Process 의 출현

- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )
- Daemon 의 사용
- IPC ( Inter Process Communication ) 의 사용

# 쓰레드를 사용한 코드

- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )
- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )

```kotlin
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    val executor = Executors.newFixedThreadPool(100)
    var vault = 5000
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault += 200
        } else Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault -= 200
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println(&quot;waiting thread terminating&quot;)
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과2](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)

- 충분히 빨라졌다!
- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )
- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )

# Thread-Safe한 자료형으로 쓰레드를 사용한 코드

![실행결과3](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)


- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.
- 하지만 그래도 문제는 존재한다

# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?

```kotlin
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicInteger

fun main(args: Array&lt;String&gt;) {
    val executor = Executors.newFixedThreadPool(4)
    var vault = AtomicInteger(5000)
    for (i in 0..999) {
        val worker = if (i % 2 == 0) Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault.addAndGet(200)
        } else Runnable {
            println(&quot;Hello this is thread $i&quot;)
            Thread.sleep(10)
            vault.addAndGet(-200)
        }
        executor.execute(worker)
    }
    executor.shutdown()
    while (!executor.isTerminated) {
        Thread.sleep(100)
        println(&quot;waiting thread terminating&quot;)
    }
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과4](/assets/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)

- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.
- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.
  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.
  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.
- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.


# 코루틴을 사용한다면?

```kotlin
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.*
import java.util.concurrent.Executors

fun main(args: Array&lt;String&gt;) {
    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()
    var vault = AtomicInteger(5000)
    runBlocking {
        for (i in 0..999) {
            if (i % 2 == 0) launch(ctx) {
                delay(10)
                println(&quot;Hello this is coroutine $i&quot;)
                vault.addAndGet(200)
            } else launch(ctx) {
                delay(10)
                println(&quot;Hello this is coroutine $i&quot;)
                vault.addAndGet(-200)
            }
        }
    }
    ctx.close()
    println(&quot;last vault value is $vault&quot;)
    println(&quot;Finished all threads&quot;)
}
```

![실행결과5](/assets/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)

# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?

원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시

보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공
  - java에서는 future
  - js/ts에서는 promise

위의 내용을 async 라는 키워드를 통해 해당 함수가 비동기의 방법을 통해 값을 리턴함을 마킹

async function은 await 이라는 키워드를 통해 완료된 시점 이후 해야할 일을 명시

# 서버 프로그래머들에게 nodejs를 보며 열광하게 만들었던 주역 uvloop

- io 처리에 대한 요청과 그 요청에 대한 완료 감지를 background thread pool을 만들어 관리
  * 예를 들어 network i/o
  * 예를 들어 file i/o
- 이를 사용하는 어플리케이션들은 io 처리 쓰레드를 uvloop에게 넘기고 완료될때 그에 대한 처리만 할 수 있도록 변경됨
- 하지만 그를 위해 언어 레벨에서, library들이, built-in 으로 비동기 처리를 지원할 방법이 필요함
  * java에 nio2가 있었음에도 불구하고 남들 다 하는 비동기 처리를 손가락빨며 쳐다볼 수 밖에 없었던 이유
  * 결국 너무 느린 발전속도로 jboss undertow 같은 WAS가 아닌 물건이 먼저 제시된 이유와 같음
- uvloop는 V8 엔진의 심장으로 google chrome browser와 nodejs를 모두가 주목할 수 밖에 없게 만든 주역임
- 그래서 비동기는 결국 공짜로 얻은 마법인가? Nope
  * spring에서 async하게 돌아간다는 것들은 전부 background thread pool 설정을 필요로 함을 알 수 있음
    - =&gt; uvloop 처럼 io 감지를 다른 백그라운드 쓰레드에게 맡겨놓은 것 뿐임
  * 그런데 그렇게 만든게 과연 uvloop 만큼 빠를까? ( = 직접 알아보자 )


# 그래서 빠르네? 정말 그럴까?

- There is no silver bullet!
</p></div><div class="pt-4 h-12"><a class="py-2 px-4 text-baseline bg-rose-500 hover:bg-rose-800 transition-colors font-bold text-white uppercase cursor-pointer rounded" href="/posts/20220725-2241xx-thread_vs_async">Read more</a></div></div></div></article><article class="block overflow-hidden break-words px-16"><div class="flex gap-12"><div><div class="min-w-32 bg-white min-h-48 p-3 mb-4 font-medium"><div class="w-32 flex-none rounded-t lg:rounded-t-none lg:rounded-l text-center shadow-lg "><div class="block rounded-t overflow-hidden text-center "><div class="bg-rose-500 text-white py-1">October</div><div class="pt-1 border-l border-r border-white bg-white"><span class="text-5xl font-bold leading-tight">23</span></div><div class="border-l border-r border-b rounded-b-lg text-center border-white bg-white -pt-2 -mb-1"><span class="text-sm">Friday</span></div><div class="pb-2 border-l border-r border-b rounded-b-lg text-center border-white bg-white"><span class="text-xs leading-normal">2020 Q4</span></div></div></div></div></div><div><header class="pt-2"><h5 class="text-2xl font-bold"><a class="cursor-pointer" href="/posts/20201023-xxxxxx-vscode-remote-container-via-docker">docker로 코드짠다?!</a></h5></header><div class="pt-4"><ul class="flex gap-2"><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/docker">docker</a></li><li class="text-sm text-gray-400 before:content-[&#x27;#&#x27;]"><a href="/tag/vscode">vscode</a></li></ul></div><div class="pt-4"><p class="line-clamp-6 cursor-pointer" href="/posts/20201023-xxxxxx-vscode-remote-container-via-docker">
## 이것이 무엇이오?

docker hub를 방황하던 도중 이상한걸 봤다. 뭐? docker로 환경을 만들고 그 안에서 개발을 해? 아니 대체 그게 무슨 소리요!

그리고 쭉 찾아보고 나서 오, 이거 좋은데? 라고 생각하게 되어 기록을 남겨놓는다.

## 예를 들어보자면 그놈의 node-gyp

항상 node-gyp는 골치덩이였다. 뭐 쩔 수 있나. nodejs에서 native로 만들어진 걸 쓰려면 필요하니...

그런데 저게 window 쪽에서는 nodejs 버전에 따라 visual studio 버전을 따진다느니 한다는 거다. 그래서 windows build tools 설치 시에 삽을 푸는 경우가 간혹 생긴다.

가장 쉬운 해결 방법은 모두가 똑같은 환경을 쓰면 된다. 다 똑같이 os를 사용하고 똑같이 인스톨하면 될거 아닌가?

이걸 vscode의 remote container가 해줄 수 있다.

## 맛 좀 보자

어떻게 하나?

0. 당연히 docker는 먼저 깔려있어야한다.
1. vscode `확장 ( Extensions )` 중에 `microsoft`가 만든 것들 중에 `Remote-Containers`가 있다. 그걸 설치한다.
2. vscode에서 f1을 눌러 command palette를 열고 `Remote Containers: Try a Sample...` 을 선택한다. 그리고 원하는 언어로 선택한다. ( 나는 예시를 위해 node를 골랐다. )

  ![이렇게 보인다.](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/001.png)

3. 그럼 vscode가 새로 열리더니 뭔가 혼자 쿵짝쿵짝한다.

과정이 다 끝났다면 Dev container terminal을 보면 node가 실행 중임이 보인다. 뭘 했나 찾아보니 project root path에 있는 server.js가 실행되었고 내용은 /로 오면 hello world 텍스트를 반환하는 http 서버가 켜진거다. 포트는 3000이고.. 브라우저를 열어서 제대로 되는지 확인해보면 된다.

뭐가 잘 안되면 재시작해보거나 하면 된다.

![dev container의 안의 내용](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/002.png)

## 오호? 나도 하나 만들어보고 싶군!

그럼 뭐 create-react-app으로 뭐 하나 만들고 그걸 devcontainer로 띄워보자.

### 어떻게 이런 짓을 벌이고 있나?

먼저 새로 띄워진 vscode를 보면 `.devcontainer` 디렉토리가 있다. 안의 내용을 보면 json 파일과 Dockerfile이 있다.

#### 먼저 Dockerfile을 보자.

```dockerfile
# See here for image contents: https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile
ARG VARIANT=&quot;14&quot;
FROM mcr.microsoft.com/vscode/devcontainers/javascript-node:0-${VARIANT}

# [Optional] Uncomment this section to install additional OS packages.
# RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \
#     &amp;&amp; apt-get -y install --no-install-recommends &lt;your-package-list-here&gt;

# [Optional] Uncomment if you want to install an additional version of node using nvm
# ARG EXTRA_NODE_VERSION=10
# RUN su node -c &quot;source /usr/local/share/nvm/nvm.sh &amp;&amp; nvm install ${EXTRA_NODE_VERSION}&quot;

# [Optional] Uncomment if you want to install more global node modules
# RUN sudo -u node npm install -g &lt;your-package-list-here&gt;
```

대충 내가 원하는 nodejs 버전을 지정할 수 있고 [https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile](https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile) 에 있는 내용을 참고하면 될 것 같다는 것을 알 수 있다.

실제로 base.Dockerfile을 보면 nodejs 배포 이미지를 사용하고 있다는 걸 볼 수 있다. 그건 ubuntu 기반 이미지이다. 그러고보면 apt-get 쓰고 있다.

뭐 대충보니 이 파일을 주물럭대면 우리가 원하는 환경을 추가로 세팅할 수 있다는 것을 알 수 있는 것이다.

#### 그 다음 json 파일을 보자.

```json
// For format details, see https://aka.ms/vscode-remote/devcontainer.json or this file&#x27;s README at:
// https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node
{
	&quot;name&quot;: &quot;Node.js&quot;,
	&quot;build&quot;: {
		&quot;dockerfile&quot;: &quot;Dockerfile&quot;,
		// Update &#x27;VARIANT&#x27; to pick a Node version: 10, 12, 14
		&quot;args&quot;: { &quot;VARIANT&quot;: &quot;12&quot; }
	},

	// Set *default* container specific settings.json values on container create.
	&quot;settings&quot;: {
		&quot;terminal.integrated.shell.linux&quot;: &quot;/bin/bash&quot;
	},

	// Add the IDs of extensions you want installed when the container is created.
	&quot;extensions&quot;: [
		&quot;dbaeumer.vscode-eslint&quot;
	],

	// Use &#x27;forwardPorts&#x27; to make a list of ports inside the container available locally.
	&quot;forwardPorts&quot;: [3000],

	// Specifies a command that should be run after the container has been created.
	&quot;postCreateCommand&quot;: &quot;yarn install&quot;,

	// Comment out the next line to run as root instead.
	&quot;remoteUser&quot;: &quot;node&quot;
}
```

방금 봤던 Dockerfile을 사용하고 있으며 버전은 12를 쓴다는 것을 알 수 있다. extensions에는 우리가 주로 사용할 확장을 넣어주면 설치가 될 거 라는걸 알 수 있다. 오? 그렇다면 prettier라던가 등등등 원하는 것을 맘껏 세팅할 수 있을 것이다. forwardPorts에는 container에서 외부로 열려야할 포트 정보를 써주면 된다 라고 써져있으니 적당히 하면 될테고..

대충 알겠으니 시작해보자.

### 먼저 만들어졌건, 이제 새로 만들건 똑같이 하면 되겠네?

일단 cra로 하나 만들어서 잘 뜨는지까지 확인해보자.

```sh
$ create-react-app devcontainer_craapp --template typescript
$ cd devcontainer_craapp
$ yarn start
```

뭐 당연히 잘 뜰 것이다.

그럼 해당 디렉토리에 `.devcontainer` 디렉토리를 만들고 안에 파일을 만들어주자.

```dockerfile
# base.Dockerfile
ARG VARIANT=14
FROM mcr.microsoft.com/vscode/devcontainers/javascript-node:${VARIANT}

# Install tslint, typescript. eslint is installed by javascript image
ARG USERNAME=node
RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive &amp;&amp; apt-get -y install --no-install-recommends build-essential autoconf automake gcc python
RUN sudo -u ${USERNAME} npm install -g --unsafe-perm tslint typescript eslint node-sass yarn
RUN sudo -u ${USERNAME} npm rebuild node-sass
RUN sudo -u ${USERNAME} yarn global add typescript node-sass create-react-app
```

난 nodejs 14를 쓸란다! 라고 해서 이렇게 했고... yarn을 쓸거고 나머지 등등 필요한 dependency를 추가로 깔았다.

```dockerfile
# Dockerfile
ARG VARIANT=14
FROM mcr.microsoft.com/vscode/devcontainers/typescript-node:${VARIANT}
```

이 파일은 뭐 할 게 없다. 중요한건 전부 base에 선언해놨으니..

`devcontainer.json` 파일은 다음과 같다.

```json
{
	&quot;name&quot;: &quot;my devcontainer cra app&quot;,
	&quot;build&quot;: {
		&quot;dockerfile&quot;: &quot;Dockerfile&quot;,
		// Update &#x27;VARIANT&#x27; to pick a Node version: 10, 12, 14
		&quot;args&quot;: { &quot;VARIANT&quot;: &quot;14&quot; }
	},

	// Set *default* container specific settings.json values on container create.
	&quot;settings&quot;: {
		&quot;terminal.integrated.shell.linux&quot;: &quot;/bin/bash&quot;
	},

	// Add the IDs of extensions you want installed when the container is created.
	&quot;extensions&quot;: [
		&quot;dbaeumer.vscode-eslint&quot;,
    &quot;ms-vscode.vscode-typescript-tslint-plugin&quot;,
    &quot;steoates.autoimport&quot;, // tsx import helper
    &quot;coenraads.bracket-pair-colorizer-2&quot;, // highlight bracket
    &quot;wmaurer.change-case&quot;, // change text macro
    &quot;mikestead.dotenv&quot;, // support dotenv
    &quot;editorconfig.editorconfig&quot;, // support editorconfig
    &quot;mhutchie.git-graph&quot;, // show git log graphically
    &quot;eamodio.gitlens&quot;, // git command helper
    &quot;oderwat.indent-rainbow&quot;, // highlight indent
    &quot;esbenp.prettier-vscode&quot;, // code formatter
    &quot;ryu1kn.partial-diff&quot;, // text diff tool
    &quot;syler.sass-indented&quot;, // support sass syntax
    &quot;mike-co.import-sorter&quot;, // ts sort import
	],

	// Use &#x27;forwardPorts&#x27; to make a list of ports inside the container available locally.
	&quot;forwardPorts&quot;: [3000],

	// Use &#x27;postCreateCommand&#x27; to run commands after the container is created.
	&quot;postCreateCommand&quot;: &quot;yarn install&quot;

	// Uncomment to connect as a non-root user. See https://aka.ms/vscode-remote/containers/non-root.
	// &quot;remoteUser&quot;: &quot;node&quot;
}
```

참고로 extension은 그저 내 취향일뿐이다. 원하는 대로 바꾸면 된다.

파일이 다 저장됬으면 해당 프로젝트 디렉토리 ( `.devcontainer` 디렉토리의 부모 디렉토리 ) 에서 vscode를 열어보자. 그럼 오른쪽 밑에 뭔가 뜬다.

![devcontainer 설정 후 vscode를 열면](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/003.png)

그럼 `Reopen in container` 를 눌러주자. ~~( 사실 이건 그냥 커맨드 팔렛트에서도 찾아서 할 수 있는 내용이다. )~~

그리고 나면 아까도 볼 수 있었던 열심히 뭔가 쿵짝쿵짝하는 내용을 볼 수 있다..

![devcontainer를 생성 중인 docker](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/004.png)

대충 뭐 다 끝나면 bash terminal을 열어 ~~( 이미 zsh가 적용되어 있다. )~~ yarn start를 쳐주고

![대망의 시작](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/005.png)

호스트 쪽의 브라우저에서 http://localhost:3000/ 을 열면 짜잔! 하고 보인다. 혹시 의심이 간다면 소스에서 좀 고쳐보자. hmr이 동작하는 것이 보일 것이다.

필요가 없어지면 커맨드 팔레트를 열어 `Remote: Close` 해주고 docker에서 container를 지우면 된다.

## 결말

이로서 개발환경 구성 시에 난 윈도우인데? 난 맥인데? 이런 물음은 필요가 없어졌다. vscode 만세다. 개발환경을 이렇게 docker를 통해 뚝딱 만들어버린다는 것은 상당한 메리트가 있을 것이다.
</p></div><div class="pt-4 h-12"><a class="py-2 px-4 text-baseline bg-rose-500 hover:bg-rose-800 transition-colors font-bold text-white uppercase cursor-pointer rounded" href="/posts/20201023-xxxxxx-vscode-remote-container-via-docker">Read more</a></div></div></div></article></div></main></div></div><footer class="block text-center border-t-2 py-16"><p>© 2012~ trazy. All right reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"slug":"20220725-2241xx-thread_vs_async","datetime":"2022-07-15T22:43:00.000+09:00","title":"쓰레드와 비동기 처리","description":"비동기를 쓰기 전에 보면 좋을지도?","tags":["concurrency","async","await","non-blocking"],"content":"\r\n# 최초의 코드\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        println(\"Hello this is thread $i\")\r\n        var next = vault + if (i % 2 == 0) 200 else -200\r\n        Thread.sleep(10);\r\n        vault = next\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과1](/assets/20220725-2241xx-thread_vs_async/2022-07-25_225747.png)\r\n\r\n- 느려! 느려도 너무 느리다!!!\r\n- 우린 더 빠르게, 더 많이 실행하고 싶다!!\r\n\r\n# 다중 프로세스 Multi-Process 의 출현\r\n\r\n- 시분할 Time-Slice 개념 적용 ( = 동시에 여러가지 일이 실행되는 것 처럼 보인다! )\r\n- Daemon 의 사용\r\n- IPC ( Inter Process Communication ) 의 사용\r\n\r\n# 쓰레드를 사용한 코드\r\n\r\n- 처리를 위해 값을 주고받는 경우 IPC 같은 복잡한 짓을 할 필요가 없음 ( = 공유된 메모리 )\r\n- 프로세스에 비해서 Context Switch 를 위해 더 적은 비용이 필요 ( = 빠르다! )\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val executor = Executors.newFixedThreadPool(100)\r\n    var vault = 5000\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault += 200\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault -= 200\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과2](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231013.png)\r\n\r\n- 충분히 빨라졌다!\r\n- 그럼에도 불구하고 1개의 CPU가 과도하게 많은 Thread를 처리하기엔 Context Switching의 Cost는 아직도 비싸다. ( = 해결할 수 없다! )\r\n- 그런데 결과가 정확하지 않네? ( = Shared Resource의 문제 )\r\n\r\n# Thread-Safe한 자료형으로 쓰레드를 사용한 코드\r\n\r\n![실행결과3](/assets/20220725-2241xx-thread_vs_async/2022-07-25_231447.png)\r\n\r\n\r\n- nts non-thread-safe 자료형이 아닌 ts한 자료형으로 정확성을 해결할 수 있었다.\r\n- 하지만 그래도 문제는 존재한다\r\n\r\n# 언제나 많은 쓰레드를 굴릴 순 없다. 쓰레드가 적다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.Executors\r\nimport java.util.concurrent.atomic.AtomicInteger\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val executor = Executors.newFixedThreadPool(4)\r\n    var vault = AtomicInteger(5000)\r\n    for (i in 0..999) {\r\n        val worker = if (i % 2 == 0) Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(200)\r\n        } else Runnable {\r\n            println(\"Hello this is thread $i\")\r\n            Thread.sleep(10)\r\n            vault.addAndGet(-200)\r\n        }\r\n        executor.execute(worker)\r\n    }\r\n    executor.shutdown()\r\n    while (!executor.isTerminated) {\r\n        Thread.sleep(100)\r\n        println(\"waiting thread terminating\")\r\n    }\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과4](/assets/20220725-2241xx-thread_vs_async/2022-07-25_235710.png)\r\n\r\n- 동시에 여러 개의 기차가 달릴 수 있는 레일이 4개 뿐이다.\r\n- 일반적인 어플리케이션에서 설정 상 권장되는 Thread의 갯수는 Logical CPU * 2 이다.\r\n  * 예를 들어 16코어 CPU에서는 32개의 Thread 까지로 제한할 것을 권장하는 어플리케이션이 많다.\r\n  * 권장 수준을 심각하게 넘어갈 경우 하는 것도 없으면서 더럽게 느리게 동작하는 걸 목격할 수 있다.\r\n- 1000개의 기차가 각자 완주하기에는 레일이 적으니 시간이 오래 걸릴 수 밖에 없다.\r\n\r\n\r\n# 코루틴을 사용한다면?\r\n\r\n```kotlin\r\nimport java.util.concurrent.atomic.AtomicInteger\r\nimport kotlinx.coroutines.*\r\nimport java.util.concurrent.Executors\r\n\r\nfun main(args: Array\u003cString\u003e) {\r\n    val ctx = Executors.newFixedThreadPool(4).asCoroutineDispatcher()\r\n    var vault = AtomicInteger(5000)\r\n    runBlocking {\r\n        for (i in 0..999) {\r\n            if (i % 2 == 0) launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(200)\r\n            } else launch(ctx) {\r\n                delay(10)\r\n                println(\"Hello this is coroutine $i\")\r\n                vault.addAndGet(-200)\r\n            }\r\n        }\r\n    }\r\n    ctx.close()\r\n    println(\"last vault value is $vault\")\r\n    println(\"Finished all threads\")\r\n}\r\n```\r\n\r\n![실행결과5](/assets/20220725-2241xx-thread_vs_async/2022-07-26_012336.png)\r\n\r\n# 빠르네? 왜 빠르지? 코루틴이란? 비동기 실행은?\r\n\r\n원래의 코루틴에서는 일반적으로 yield 키워드를 통해 현재 지점에서 다른 함수의 실행으로 통제권을 넘길 수 있음을 명시\r\n\r\n보통의 언어에서 비동기 처리가 완료될 경우 return 되는 값에 대한 참조에 접근할 방법을 제공\r\n  - java에서는 future\r\n  - js/ts에서는 promise\r\n\r\n위의 내용을 async 라는 키워드를 통해 해당 함수가 비동기의 방법을 통해 값을 리턴함을 마킹\r\n\r\nasync function은 await 이라는 키워드를 통해 완료된 시점 이후 해야할 일을 명시\r\n\r\n# 서버 프로그래머들에게 nodejs를 보며 열광하게 만들었던 주역 uvloop\r\n\r\n- io 처리에 대한 요청과 그 요청에 대한 완료 감지를 background thread pool을 만들어 관리\r\n  * 예를 들어 network i/o\r\n  * 예를 들어 file i/o\r\n- 이를 사용하는 어플리케이션들은 io 처리 쓰레드를 uvloop에게 넘기고 완료될때 그에 대한 처리만 할 수 있도록 변경됨\r\n- 하지만 그를 위해 언어 레벨에서, library들이, built-in 으로 비동기 처리를 지원할 방법이 필요함\r\n  * java에 nio2가 있었음에도 불구하고 남들 다 하는 비동기 처리를 손가락빨며 쳐다볼 수 밖에 없었던 이유\r\n  * 결국 너무 느린 발전속도로 jboss undertow 같은 WAS가 아닌 물건이 먼저 제시된 이유와 같음\r\n- uvloop는 V8 엔진의 심장으로 google chrome browser와 nodejs를 모두가 주목할 수 밖에 없게 만든 주역임\r\n- 그래서 비동기는 결국 공짜로 얻은 마법인가? Nope\r\n  * spring에서 async하게 돌아간다는 것들은 전부 background thread pool 설정을 필요로 함을 알 수 있음\r\n    - =\u003e uvloop 처럼 io 감지를 다른 백그라운드 쓰레드에게 맡겨놓은 것 뿐임\r\n  * 그런데 그렇게 만든게 과연 uvloop 만큼 빠를까? ( = 직접 알아보자 )\r\n\r\n\r\n# 그래서 빠르네? 정말 그럴까?\r\n\r\n- There is no silver bullet!\r\n"},{"slug":"20201023-xxxxxx-vscode-remote-container-via-docker","datetime":"2020-10-23T00:00:00.000+09:00","title":"docker로 코드짠다?!","description":"vscode와 docker의 하모니","tags":["docker","vscode"],"content":"\r\n## 이것이 무엇이오?\r\n\r\ndocker hub를 방황하던 도중 이상한걸 봤다. 뭐? docker로 환경을 만들고 그 안에서 개발을 해? 아니 대체 그게 무슨 소리요!\r\n\r\n그리고 쭉 찾아보고 나서 오, 이거 좋은데? 라고 생각하게 되어 기록을 남겨놓는다.\r\n\r\n## 예를 들어보자면 그놈의 node-gyp\r\n\r\n항상 node-gyp는 골치덩이였다. 뭐 쩔 수 있나. nodejs에서 native로 만들어진 걸 쓰려면 필요하니...\r\n\r\n그런데 저게 window 쪽에서는 nodejs 버전에 따라 visual studio 버전을 따진다느니 한다는 거다. 그래서 windows build tools 설치 시에 삽을 푸는 경우가 간혹 생긴다.\r\n\r\n가장 쉬운 해결 방법은 모두가 똑같은 환경을 쓰면 된다. 다 똑같이 os를 사용하고 똑같이 인스톨하면 될거 아닌가?\r\n\r\n이걸 vscode의 remote container가 해줄 수 있다.\r\n\r\n## 맛 좀 보자\r\n\r\n어떻게 하나?\r\n\r\n0. 당연히 docker는 먼저 깔려있어야한다.\r\n1. vscode `확장 ( Extensions )` 중에 `microsoft`가 만든 것들 중에 `Remote-Containers`가 있다. 그걸 설치한다.\r\n2. vscode에서 f1을 눌러 command palette를 열고 `Remote Containers: Try a Sample...` 을 선택한다. 그리고 원하는 언어로 선택한다. ( 나는 예시를 위해 node를 골랐다. )\r\n\r\n  ![이렇게 보인다.](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/001.png)\r\n\r\n3. 그럼 vscode가 새로 열리더니 뭔가 혼자 쿵짝쿵짝한다.\r\n\r\n과정이 다 끝났다면 Dev container terminal을 보면 node가 실행 중임이 보인다. 뭘 했나 찾아보니 project root path에 있는 server.js가 실행되었고 내용은 /로 오면 hello world 텍스트를 반환하는 http 서버가 켜진거다. 포트는 3000이고.. 브라우저를 열어서 제대로 되는지 확인해보면 된다.\r\n\r\n뭐가 잘 안되면 재시작해보거나 하면 된다.\r\n\r\n![dev container의 안의 내용](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/002.png)\r\n\r\n## 오호? 나도 하나 만들어보고 싶군!\r\n\r\n그럼 뭐 create-react-app으로 뭐 하나 만들고 그걸 devcontainer로 띄워보자.\r\n\r\n### 어떻게 이런 짓을 벌이고 있나?\r\n\r\n먼저 새로 띄워진 vscode를 보면 `.devcontainer` 디렉토리가 있다. 안의 내용을 보면 json 파일과 Dockerfile이 있다.\r\n\r\n#### 먼저 Dockerfile을 보자.\r\n\r\n```dockerfile\r\n# See here for image contents: https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile\r\nARG VARIANT=\"14\"\r\nFROM mcr.microsoft.com/vscode/devcontainers/javascript-node:0-${VARIANT}\r\n\r\n# [Optional] Uncomment this section to install additional OS packages.\r\n# RUN apt-get update \u0026\u0026 export DEBIAN_FRONTEND=noninteractive \\\r\n#     \u0026\u0026 apt-get -y install --no-install-recommends \u003cyour-package-list-here\u003e\r\n\r\n# [Optional] Uncomment if you want to install an additional version of node using nvm\r\n# ARG EXTRA_NODE_VERSION=10\r\n# RUN su node -c \"source /usr/local/share/nvm/nvm.sh \u0026\u0026 nvm install ${EXTRA_NODE_VERSION}\"\r\n\r\n# [Optional] Uncomment if you want to install more global node modules\r\n# RUN sudo -u node npm install -g \u003cyour-package-list-here\u003e\r\n```\r\n\r\n대충 내가 원하는 nodejs 버전을 지정할 수 있고 [https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile](https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node/.devcontainer/base.Dockerfile) 에 있는 내용을 참고하면 될 것 같다는 것을 알 수 있다.\r\n\r\n실제로 base.Dockerfile을 보면 nodejs 배포 이미지를 사용하고 있다는 걸 볼 수 있다. 그건 ubuntu 기반 이미지이다. 그러고보면 apt-get 쓰고 있다.\r\n\r\n뭐 대충보니 이 파일을 주물럭대면 우리가 원하는 환경을 추가로 세팅할 수 있다는 것을 알 수 있는 것이다.\r\n\r\n#### 그 다음 json 파일을 보자.\r\n\r\n```json\r\n// For format details, see https://aka.ms/vscode-remote/devcontainer.json or this file's README at:\r\n// https://github.com/microsoft/vscode-dev-containers/tree/v0.134.0/containers/javascript-node\r\n{\r\n\t\"name\": \"Node.js\",\r\n\t\"build\": {\r\n\t\t\"dockerfile\": \"Dockerfile\",\r\n\t\t// Update 'VARIANT' to pick a Node version: 10, 12, 14\r\n\t\t\"args\": { \"VARIANT\": \"12\" }\r\n\t},\r\n\r\n\t// Set *default* container specific settings.json values on container create.\r\n\t\"settings\": {\r\n\t\t\"terminal.integrated.shell.linux\": \"/bin/bash\"\r\n\t},\r\n\r\n\t// Add the IDs of extensions you want installed when the container is created.\r\n\t\"extensions\": [\r\n\t\t\"dbaeumer.vscode-eslint\"\r\n\t],\r\n\r\n\t// Use 'forwardPorts' to make a list of ports inside the container available locally.\r\n\t\"forwardPorts\": [3000],\r\n\r\n\t// Specifies a command that should be run after the container has been created.\r\n\t\"postCreateCommand\": \"yarn install\",\r\n\r\n\t// Comment out the next line to run as root instead.\r\n\t\"remoteUser\": \"node\"\r\n}\r\n```\r\n\r\n방금 봤던 Dockerfile을 사용하고 있으며 버전은 12를 쓴다는 것을 알 수 있다. extensions에는 우리가 주로 사용할 확장을 넣어주면 설치가 될 거 라는걸 알 수 있다. 오? 그렇다면 prettier라던가 등등등 원하는 것을 맘껏 세팅할 수 있을 것이다. forwardPorts에는 container에서 외부로 열려야할 포트 정보를 써주면 된다 라고 써져있으니 적당히 하면 될테고..\r\n\r\n대충 알겠으니 시작해보자.\r\n\r\n### 먼저 만들어졌건, 이제 새로 만들건 똑같이 하면 되겠네?\r\n\r\n일단 cra로 하나 만들어서 잘 뜨는지까지 확인해보자.\r\n\r\n```sh\r\n$ create-react-app devcontainer_craapp --template typescript\r\n$ cd devcontainer_craapp\r\n$ yarn start\r\n```\r\n\r\n뭐 당연히 잘 뜰 것이다.\r\n\r\n그럼 해당 디렉토리에 `.devcontainer` 디렉토리를 만들고 안에 파일을 만들어주자.\r\n\r\n```dockerfile\r\n# base.Dockerfile\r\nARG VARIANT=14\r\nFROM mcr.microsoft.com/vscode/devcontainers/javascript-node:${VARIANT}\r\n\r\n# Install tslint, typescript. eslint is installed by javascript image\r\nARG USERNAME=node\r\nRUN apt-get update \u0026\u0026 export DEBIAN_FRONTEND=noninteractive \u0026\u0026 apt-get -y install --no-install-recommends build-essential autoconf automake gcc python\r\nRUN sudo -u ${USERNAME} npm install -g --unsafe-perm tslint typescript eslint node-sass yarn\r\nRUN sudo -u ${USERNAME} npm rebuild node-sass\r\nRUN sudo -u ${USERNAME} yarn global add typescript node-sass create-react-app\r\n```\r\n\r\n난 nodejs 14를 쓸란다! 라고 해서 이렇게 했고... yarn을 쓸거고 나머지 등등 필요한 dependency를 추가로 깔았다.\r\n\r\n```dockerfile\r\n# Dockerfile\r\nARG VARIANT=14\r\nFROM mcr.microsoft.com/vscode/devcontainers/typescript-node:${VARIANT}\r\n```\r\n\r\n이 파일은 뭐 할 게 없다. 중요한건 전부 base에 선언해놨으니..\r\n\r\n`devcontainer.json` 파일은 다음과 같다.\r\n\r\n```json\r\n{\r\n\t\"name\": \"my devcontainer cra app\",\r\n\t\"build\": {\r\n\t\t\"dockerfile\": \"Dockerfile\",\r\n\t\t// Update 'VARIANT' to pick a Node version: 10, 12, 14\r\n\t\t\"args\": { \"VARIANT\": \"14\" }\r\n\t},\r\n\r\n\t// Set *default* container specific settings.json values on container create.\r\n\t\"settings\": {\r\n\t\t\"terminal.integrated.shell.linux\": \"/bin/bash\"\r\n\t},\r\n\r\n\t// Add the IDs of extensions you want installed when the container is created.\r\n\t\"extensions\": [\r\n\t\t\"dbaeumer.vscode-eslint\",\r\n    \"ms-vscode.vscode-typescript-tslint-plugin\",\r\n    \"steoates.autoimport\", // tsx import helper\r\n    \"coenraads.bracket-pair-colorizer-2\", // highlight bracket\r\n    \"wmaurer.change-case\", // change text macro\r\n    \"mikestead.dotenv\", // support dotenv\r\n    \"editorconfig.editorconfig\", // support editorconfig\r\n    \"mhutchie.git-graph\", // show git log graphically\r\n    \"eamodio.gitlens\", // git command helper\r\n    \"oderwat.indent-rainbow\", // highlight indent\r\n    \"esbenp.prettier-vscode\", // code formatter\r\n    \"ryu1kn.partial-diff\", // text diff tool\r\n    \"syler.sass-indented\", // support sass syntax\r\n    \"mike-co.import-sorter\", // ts sort import\r\n\t],\r\n\r\n\t// Use 'forwardPorts' to make a list of ports inside the container available locally.\r\n\t\"forwardPorts\": [3000],\r\n\r\n\t// Use 'postCreateCommand' to run commands after the container is created.\r\n\t\"postCreateCommand\": \"yarn install\"\r\n\r\n\t// Uncomment to connect as a non-root user. See https://aka.ms/vscode-remote/containers/non-root.\r\n\t// \"remoteUser\": \"node\"\r\n}\r\n```\r\n\r\n참고로 extension은 그저 내 취향일뿐이다. 원하는 대로 바꾸면 된다.\r\n\r\n파일이 다 저장됬으면 해당 프로젝트 디렉토리 ( `.devcontainer` 디렉토리의 부모 디렉토리 ) 에서 vscode를 열어보자. 그럼 오른쪽 밑에 뭔가 뜬다.\r\n\r\n![devcontainer 설정 후 vscode를 열면](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/003.png)\r\n\r\n그럼 `Reopen in container` 를 눌러주자. ~~( 사실 이건 그냥 커맨드 팔렛트에서도 찾아서 할 수 있는 내용이다. )~~\r\n\r\n그리고 나면 아까도 볼 수 있었던 열심히 뭔가 쿵짝쿵짝하는 내용을 볼 수 있다..\r\n\r\n![devcontainer를 생성 중인 docker](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/004.png)\r\n\r\n대충 뭐 다 끝나면 bash terminal을 열어 ~~( 이미 zsh가 적용되어 있다. )~~ yarn start를 쳐주고\r\n\r\n![대망의 시작](/assets/20201023-xxxxxx-vscode-remote-container-via-docker/005.png)\r\n\r\n호스트 쪽의 브라우저에서 http://localhost:3000/ 을 열면 짜잔! 하고 보인다. 혹시 의심이 간다면 소스에서 좀 고쳐보자. hmr이 동작하는 것이 보일 것이다.\r\n\r\n필요가 없어지면 커맨드 팔레트를 열어 `Remote: Close` 해주고 docker에서 container를 지우면 된다.\r\n\r\n## 결말\r\n\r\n이로서 개발환경 구성 시에 난 윈도우인데? 난 맥인데? 이런 물음은 필요가 없어졌다. vscode 만세다. 개발환경을 이렇게 docker를 통해 뚝딱 만들어버린다는 것은 상당한 메리트가 있을 것이다.\r\n"}],"tags":["async","await","concurrency","docker","non-blocking","vscode"]},"__N_SSG":true},"page":"/","query":{},"buildId":"lzqqrgsdoJkOt9BxdDE46","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>